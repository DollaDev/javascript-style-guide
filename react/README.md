# Rapid7 React/JSX Style Guide

*A mostly reasonable approach to React and JSX*

## Table of Contents

  1. [Basic Rules](#basic-rules)
  1. [Naming](#naming)
  1. [Declaration](#declaration)
  1. [Alignment](#alignment)
  1. [Quotes](#quotes)
  1. [Spacing](#spacing)
  1. [Props](#props)
  1. [Parentheses](#parentheses)
  1. [Tags](#tags)
  1. [Methods](#methods)
  1. [Ordering](#ordering)

## Basic Rules

  - [1.1](#1.1) <a name='1.1'></a> **File configuration**

    + Only include one React component per file, with the exception of components generated by `styled-components`.
    + Components generated with `styled-components` are located in the same file as the component they are used in.
  
  - [1.2](#1.2) <a name='1.2'></a> **Code conventions**

    + Always use JSX syntax.
    + Prefer the use of functional components when state and lifecycle methods are not needed.
    + When state or lifecycle methods are needed, use the `Component` or `PureComponent` class (not `createClass`)
    + Do not use `React.createElement` unless you're initializing the app from a file that is not JSX.

## Naming
  
  - [2.1](#2.1) <a name='2.1'></a> **Extensions**: Use `.js` extension for React components.
  
  - [2.2](#2.2) <a name='2.2'></a> **Filename**: Use PascalCase for filenames. E.g., `ReservationCard.js`.
  
  - [2.3](#2.3) <a name='2.3'></a> **Reference Naming**: Use PascalCase for React components and camelCase for their instances:

  ```javascript
  // bad
  const reservationCard = require('./ReservationCard');

  // good
  const ReservationCard = require('./ReservationCard');

  // bad
  const ReservationItem = <ReservationCard />;

  // good
  const reservationItem = <ReservationCard />;
  ```
  
  - [2.4](#2.4) <a name='2.4'></a> **Component Naming**: Use the filename as the component name. For example, `ReservationCard.js` should have a reference name of `ReservationCard`.

  ```javascript
  // bad
  const FooterComponent = require('./Footer')

  // good
  const Footer = require('./Footer')
  ```


## Declaration
  
  - [3.1](#3.1) <a name='3.1'></a> **Display name**: If applying `displayName` to a component, it should match the name of the component itself.
  
  > NOTE: You can also use third-party plugins to programmatically add `displayName`, example with a [babel plugin](https://www.npmjs.com/package/babel-plugin-add-react-displayname)

  ```javascript
  // bad
  export default class ReservationCard extends Component {
  }
  
  export default function ReservationCard() {
    //
  }

  // good
  export default class ReservationCard extends Component {
    static displayName = 'ReservationCard';
  }
  
  export default function ReservationCard() {
    //
  }
  
  ReservationCard.displayName = 'ReservationCard';
  ```
  
  - [3.2](#3.2) <a name='3.2'></a>: **Statics**: When using the `Component` or `PureComponent` class, define `propTypes`, `defaultProps`, and `contextTypes` with `static` keywords instead of direct assignment.

  ```javascript
  // bad
  class Link extends Component {
    // rest
  }
  
  Link.propTypes = {
    id: PropTypes.number.isRequired,
    url: PropTypes.string.isRequired,
    text: PropTypes.string
  };
  
  Link.defaultProps = {
    text: 'Hello World'
  };
  
  Link.methodsAreOk() {
    return true;
  };
  
  // good
  class Link extends Component {
    static propTypes = {
      id: PropTypes.number.isRequired,
      url: PropTypes.string.isRequired,
      text: PropTypes.string
    };

    static defaultProps = {
      text: 'Hello World'
    };

    static methodsAreOk() {
      return true;
    }

    // rest
  }

  export default Link;
  ```
  
  - [3.3](#3.3) <a name='3.3'></a>: **Accessing instance values**: When accessing `props`, `state`, or `context`, they should be destructured at the top of the function scope.
  
  > Why? This explicitly defines the contract immediately, which makes understanding what internal values are used much easier.
  
  ```javascript
  // bad
  handleFoo = () => {
    if (this.state.bar === 'bar') {
      this.props.getBar();
    };
  };
  
  // good
  handleFoo = () => {
    const {getBar} = this.props;
    const {bar} = this.state;
    
    if (bar === 'bar') {
      getBar();
    }
  };
  ```
  
## Alignment
  
  - [4.1](#4.1) <a name='4.1'></a> **Tag alignment**: Closing tag must align with the opening tag.

  ```javascript
  // bad
  <Foo someParam="bar"
       someSecondParam="baz" />

  // good
  <Foo
    someParam="bar"
    someSecondParam="baz"
  />
  ```
  
  - [4.2](#4.2) <a name='4.2'></a> **Single- vs multi-prop**: When the tag as a single prop passed, it should be on a single line, and when multiple props are passed it should be newline-separated.

  ```javascript
  // bad
  <Foo
    someParam="bar"
  />
  <Bar someParam="baz"
       someSecondParam="quz" />

  // good
  <Foo someParam="bar" />
  
  <Bar
    someParam="baz"
    someSecondParam="quz"
  />
  ```

## Quotes
  
  - [5.1](#5.1) <a name='5.1'></a>  **Types**: Always use double quotes (`"`) for JSX attributes.

  > Why? JSX attributes [can't contain escaped quotes](http://eslint.org/docs/rules/jsx-quotes), so double quotes make conjunctions like `"don't"` easier to type. Also, it allows for easier distinction between JS logic and static props.

  ```javascript
  // bad
  <Foo bar='bar'/>

  // good
  <Foo bar="bar"/>
  ```

## Spacing
  
  - [6.1](#6.1) <a name='6.1'></a>  **Tags**: Always have a single ending space in your self-closing tag.

  ```javascript
  // bad
  <Foo/>
  <Bar                 />
  <Baz
   />

  // good
  <Foo />
  ```

## Props
  
  - [7.1](#7.1) <a name='7.1'></a>  **Naming**: Always use camelCase for custom prop names.
  
  > NOTE: Standard HTML attributes that use kebab casing (such as `data-*` attributes) should still use kebab casing.

  ```javascript
  // bad
  <Foo
    phone_number={12345678}
    USERNAME="hello"
  />

  // good
  <Foo
    phoneNumber={12345678}
    userName="hello"
  />
  ```

## Parentheses
  
  - [8.1](#8.1) <a name='8.1'></a>  **Component returns**: Wrap multiline JSX tags in parentheses when returned:

  ```javascript
  /// bad
  render() {
    return <MyComponent className="long body" foo="bar">
             <MyChild />
           </MyComponent>;
  }
  
  render() {
    return <Foo
        bar="bar"
        baz="baz"
      />
  }

  // good
  render() {
    return (
      <MyComponent className="long body" foo="bar">
        <MyChild />
      </MyComponent>
    );
  }
  
  render() {
    return (
      <Foo
        bar="bar"
        baz="baz"
      />
    );
  }
  ```

## Tags
  
  - [9.1](#9.1) <a name='9.1'></a>: **Without children**: Always self-close tags that have no children.

  ```javascript
  // bad
  <Foo className="stuff"></Foo>

  // good
  <Foo className="stuff"/>
  ```
  
  - [9.2](#9.2) <a name='9.2'></a>: **With children**: If your component has multi-line properties, close its tag on a new line.

  ```javascript
  // bad
  <Foo
    bar="bar"
    baz="baz" />

  // good
  <Foo
    bar="bar"
    baz="baz"
  />
  ```

## Methods
  
  - [10.1](#10.1) <a name='10.1'></a>: **Internal**: Do not use underscored prefixes for internal methods of a React component.

  ```javascript
  // bad
  class Foo extends React.Component {
    _onClickSubmit() {
      // do stuff
    }

    // other stuff
  }

  // good
  class Foo extends React.Component {
    onClickSubmit() {
      // do stuff
    }

    // other stuff
  }
  ```
  
  - [10.2](#10.2) <a name='10.2'></a>: **Render**: Methods that return a JSX element (aka "render methods") should be prefixed with the word `render`.
  
  ```javascript
  // bad
  class Foo extends React.Component {
    getListItem = (item) => {
      return (
        <ListItem
          param={item.foo}
          paramOther={item.bar}
        />
      );
    };
    
    // other stuff
  }
  
  // good
  class Foo extends React.Component {
    renderListItem = (item) => {
      return (
        <ListItem
          param={item.foo}
          paramOther={item.bar}
        />
      );
    };
    
    // other stuff
  }
  ```

## Ordering
  
  - [11.1](#11.1) <a name='11.1'></a>: **Component class**: Ordering for class extending either `Component` or `PureComponent`:

  1. displayName
  2. propTypes
  3. contextTypes
  4. childContextTypes
  4. defaultProps
  5. getDefaultProps
  6. getChildContext
  7. getInitialState
  8. state
  9. constructor
  10. getDerivedStateFromProps
  11. componentWillMount / UNSAFE_componentWillMount
  12. componentDidMount
  13. componentWillReceiveProps / UNSAFE_componentWillReceiveProps
  14. shouldComponentUpdate
  15. componentWillUpdate / UNSAFE_componentWillUpdate
  16. componentDidUpdate
  17. componentDidCatch
  18. componentWillUnmount
  19. Static methods (preferrably alphabetized)
  20. Instance values (preferrably alphabetized)
  21. Instance methods built with creators (preferrably alphabetized)
  21. Standard instance methods (preferrably alphabetized)
  22. Render methods
  23. render
  
    + "Instance methods built with creators" refers to methods that are generated with `create*` functions, or with memoize functions.
  
  ```javascript
  // standard instance method
  handleFoo = () => {};
  
  // instance methods build with creators
  handleFoo = createHandleFoo(this);
  handleBar = moize(() => {});
  ```

**[â¬† back to top](#table-of-contents)**
